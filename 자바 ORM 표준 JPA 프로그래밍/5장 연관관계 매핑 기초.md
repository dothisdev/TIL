### 객체와 테이블의 연관관계 차이
1. 객체를 참조를 통해 연관관계를 맺는다
	1. 단방향으로 연관관계를 맺는다
2. 테이블은 외래키를 통해 연관관계를 맺는다
	1. 양방향으로 연관관계를 맺는다

객체는 참조 필드를 통해 A->B로 연관관계를 맺을 수 있지만 반대 방향의 B->A로 연관관계를 맺을 수 없다, 하지만 테이블은 외래키 필드를 통해 A->B, B->A로 양방향에 연관관계를 맺는게 가능하다.
객체에서 양방향 연관관계를 맺을 수는 없고 A, B객체에 각각 단방향 연관관계를 둬 양방향 연관관계인척 하는건 가능하다
### @JoinColumn
조인 컬럼으로 외래 키를 매핑할 때 사용
## 연관관계의 주인
연관관계의 주인은 실제 테이블의 연관관계를 결정하는 외래키를 관리하는 쪽을 말한다.

객체에서 양방향 연관관계를 맺을때 연관관계의 주인을 지정해줘야 한다.

왜냐하면 객체와 테이블에 연관관계의 차이가 있기 때문이다.
양방향 연관관계를 맺을때 객체는 각 객체에 참조를 둬 연관관계를 관리하는 포인트가 2곳이지만, 테이블은 외래키 하나로 관리하는 포인트가 1곳이다.
이런 차이를 좁히기 위해 객체의 연관관계 포인트 2곳중 1곳을 외래키 관리필드로 지정해야 하는데 연관관계의 주인설정을 통해 1곳을 외래키 관리필드로 지정하고, 나머지 포인트는 읽기전용으로 설정해 차이를 좁힐 수 있다
#### mappedBy
연관관계의 주인을 지정한다.
1. 주인이 아닌쪽이 mappedBy를 사용한다
2. mappedBy 속성을 사용하면 필드가 읽기전용으로 설정된다.
#### 외래키 관리
테이블에서 외래키 관리는 항상 다 쪽이 외래키를 관리한다. 따라서 JPA의 @ManyToOne에 mappedBy 속성이 존재하지 않는다.
### 양방향 연관관계의 주의점
##### 연관관계 주인이 아닌곳에서의 설정
객체에서 양방향 연관관계를 설정할때 연관관계의 주인이 아닌곳에서만 설정하면 DB에 반영이 안된다, 왜냐하면 연관관계의 주인이 아닌곳은 읽기전용 속성이기 때문
##### 순수한 객체를 고려한 양방향 연관관계
양방향 연관관계를 설정한 상태에서 연관관계의 주인쪽에만 값을 저장하는것은 순수한 객체를 고려했을때 안전하지 않다, 순수한 객체를 고려한다면 양방향에 연관관계 값을 저장해야한다.

예를들어 멤버와, 팀이 있다 팀이 연관관계 주인이 아니여서 멤버에만 팀설정을 한다면 DB에는 잘 반영이 되겠지만 순수한 객체로서 팀을 조회한다면 저장된 멤버가 없어 정확한 정보를 조회하지 못하는 문제가 발생한다. 그래서 순수한 객체를 고려해 양방향에 연관관계 값을 설정해줘야한다.
##### 무한 루프
양방향 매핑시 무한 루프에 빠질 수 있다. 
예를들어 member.toString()를 호출했을때 member.getTeam()을 호출하고 team.toString()을 호출하고 다시 member.toString()을 호출하게 되면서 무한 루프가 발생한다 이럴때는 toString에서 연관객체를 제외하여 출력하는등의 조치가 필요하다.

출처: 김영한,『자바 ORM 표준 JPA 프로그래밍』에이콘출판사(2015)
