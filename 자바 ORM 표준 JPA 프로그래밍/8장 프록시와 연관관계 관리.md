## 즉시로딩과 지연로딩
엔티티를 로딩할때 잘 사용하지 않거나 많은양의 연관된 엔티티를 한번에 로딩하는것은 비효율적이고 성능에 좋지 않다. 그래서 JPA는 지연로딩을 지원한다
### 즉시로딩
(fetch = FetchType.EAGER)
연관된 엔티티를 즉시 로딩한다
### 지연로딩
(fetch = FetchType.LAZY)
연관된 엔티티를 프록시로 저장해놨다가 실제로 사용하는 순간에 프로식로 로딩하여 사용한다
##### 컬렉션 래퍼
하이버네이트가 엔티티를 영속 상태로 만들때 엔티티에 컬렉션이 있으면 이 컬렉션을 추적하고 관리할 목적으로 원본 컬렉션을 하이버네이트가 제공하는 내장 컬렉션으로 변경하는데 이를 컬렉션 래퍼라 부른다.

컬렉션 래퍼는 프록시로서도 기능해 지연 로딩을 처리한다.
### JPA 엔티티 로딩 기본전략
###### 로딩전략 기본값
@ManyToOne, @OneToOne : 즉시 로딩
@OneToMany, @ManyToMany : 지연 로딩
해당 필드는 엔티티 컬렉션이기 때문에 한번에 많은 양의 엔티티를 불러 올 수 있어 지연로딩 사용
##### 내부 조인, 외부조인 
###### @ManyToOne, @OneToOne
(optional = false) : 내부 조인
(optional = true) : 외부 조인
###### @OneToMany, @ManyToMany
(optional = false) : 외부 조인
(optional = true) : 외부 조인
JPA에서 컬렉션 로딩은 외부 조인만 지원하는데, 내부 조인을 사용한다면 One:Many를 예로 들어 One에 해당하는 Many가 없는경우 One까지 조회 되지 않게 되어 JPA는 컬렉션 로딩은 외부 조인만 지원한다.
## 영속성 전이: CASCADE
영속성 전이는 엔티티의 영속성 영향이 연관 엔티티에게 까지 가는걸 말한다.

예를들어 엔티티를 저장하면 엔티티는 영속상태로 전환된다 이때 연관된 엔티티도 영향을 받아 함께 영속상태로 전환되는경우가 바로 영속성 전이를 사용한 경우다.

영속성 전이를 사용하면 연관된 엔티티도 함께 저장, 삭제등을 할 수 있어 편리하다.
### 종류
* ALL
* PERSIST
* MERGE
* REMOVE
* REFRESH
* DETACH
PERSIST, REMOVE 타입은 바로 전이가 발생하지 않고 em.flush() 호출 시점에 전이가 발생한다.

실생활 예 : 과자상자를 보관할때 -> 영속성 전이를 사용하면 내용물도 보관, 사용안하면 내용물은 제외하고 상자만 보관
## 고아 객체 제거: orphanRemoval
orphanRemoval 속성을 통해 고아 객체 제거기능을 사용할 수 있다.
### 고아 객체 제거
고아 객체 제거란 부모 엔티티가 자식 엔티티의 참조를 끊으면 자동으로 제거해주는 기능을 말한다.

고아 객체 제거는 flush() 호출 시점에 발생한다.
```java
parent.getChildren().remove(0)// 자식 엔티티 자동으로 제거 (제거상태로 전환)
```
예를들어 게시물 엔티티가 참조하는 댓글 엔티티를 제거하여 참조를 끊으면 제거한 댓글 엔티티가 고아객체로 인식되어 자동으로 제거된다.

실생활 예 : 책장에 있는 책을 뺄때 -> 고아 객체 제거를 사용하면 책을 버림, 사용안하면 다른곳에 보관
#### 주의점
사용할때 주의점은 고아 객체로 제거될 엔티티가 다른곳에서도 참조 되면 안된다. 즉 독립적으로 참조된 엔티티여야 한다. 왜냐하면 문제가 발생할 수 있기 때문이다.

예를들어 댓글 엔티티가 게시물의 참조를 끊으면 게시물이 고아 객체가 되어 제거된다. 이때 게시물을 참조 하던 다른 댓글 엔티티들은 참조하던 게시물을 조회하지 못해 문제가 발생하게 된다.

그래서 orphanRemoval은 @OneToOne, @OneToMany만 사용가능하다
why?) 이러한 연관관계는 높은 확률로 독립적으로 참조하고, @ManyToOne, @ManyToMany과 같은 연관관계는 여러곳에서 참조하기 때문

출처: 김영한,『자바 ORM 표준 JPA 프로그래밍』에이콘출판사(2015)
