### N+1 문제
N+1 문제는 처음 조회한 데이터 개수(N)만큼 추가로 조회 쿼리가 발생하는 성능 문제를 말한다.
N+1 문제는 많은 조회 쿼리를 발생시켜 조회 성능에 악영향을 끼친다.

N+1 문제가 발생하는 예로 JQPL를 통해 멤버 엔티티들을 조회 하였는데 멤버의 연관 엔티티인 팀의 패치 전략이 즉시 로딩이여서 멤버 엔티티 수(N)만큼 팀 조회 쿼리가 발생하는 경우가 있다.
#### N+1 문제를 해결하는 방법
##### 패치 조인 사용
JPQL의 패치 조인을 사용해 패치 조인 대상까지 한번에 조회 시켜 N+1문제를 방지한다.
이때 이미 대상을 로딩해 글로벌 패치 전략은 무의미하고, 패치 조인을 사용하면 불필요한 엔티티까지 조회 될 수 있다.
##### 하이버네이트 @BatchSize
@BatchSize를 통해 SQL IN절을 사용해 size값 만큼 데이터를 한번에 조회할 수 있다.
예를들어 팀엔티티에 멤버가 10명 존재하고 size가 5면 즉시 로딩일때는 조회 쿼리를 2번 날려 멤버를 조회하고, 지연 로딩일때는 사용 시점에 한번에 5개의 멤버 엔티티를 조회하고 6번째 이상 멤버 엔티티를 조회할때 조회 쿼리를 날려 나머지 멤버 엔티티를 조회한다.
##### 하이버네이트 @Fetch(FetchMode.SUBSELECT)
해당 어노테이션을 통해 연관 엔티티를 조회할때 서브 쿼리를 날려 N+1문제 해결 가능
```sql
SELECT O FROM ORDERS O
 WHERE O.MEMBEER_ID IN (
		SELECT M.ID
            	 FROM MEMBER M
		 WHERE M.ID > 10
			)
```
즉시 로딩 설정시 조회시점, 지연 로딩시 연관 엔티티 사용시점에 서브 쿼리를 날린다.

지연 로딩을 사용하더라도 특정 엔티티가 연관 엔티티를 조회할때 해당 엔티티의 연관 엔티티를 조회하는게 아니라 다음과 같이 서브 쿼리를 날려, 특정 엔티티뿐만 아니라 조회한 모든 엔티티의 연관 엔티티를 조회하기 때문에 마찬가지로 불필요한 엔티티가 조회 될 수 있다.