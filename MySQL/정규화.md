# 정규화
데이터베이스 테이블을 구조화해, [[TIL/MySQL/이상현상.md|이상현상]]과 데이터의 중복을 방지하고 무결성을 유지시키는 과정
## 장점
* 중복을 줄일 수 있다
* 데이터 관리를 효율적으로 할 수 있다.
* 정확한 데이터 구조를 형성 시킬 수 있다
* 삽입, 삭제, 수정 이상현상을 막을 수 있다
* 데이터 무결성을 유지시킬 수 있다.
## 단점
* 테이블이 많아지면서 구조 파악이 힘들어짐
* SQL 쿼리가 복잡해짐
* 복잡한 Join 쿼리 사용으로 인한 성능저하가 발생할 수 있다.
* 관리와 유지보수가 어려워짐
## 단계에 따른 정규화
### 제 1 정규화
![[Pasted image 20250305115146.png]] ![[Pasted image 20250305115116.png]]
테이블의 각 컬럼이 원자값(하나의 값)을 갖게한다.
e.g) 취미 테이블의 취미 필드는 여러개의 취미가 저장되지만 제 1정규화를 거치면서 각 필드에 하나의 취미 저장을 허용한다
##### 효과
* 삭제 이상현상을 막을 수 있다
* 데이터 관리를 효율적으로 할 수 있다
	* 검색
		* 기존에는 like연산자를 통해 검색할 취미가 포함된 튜플을 가져와야 하지만 제 1 정규화 이후 등호 연산자를 사용하여 효율적으로 검색 가능
	* 삭제
		* 추신수의 영화, 음악 취미중 음악을 제거하는경우에
			* 이전
				* 취미를 select하고 가져온 데이터에서 음악을 제거한 문자열로 update
			* 이후
				* 이름이 추신수 취미가 음악인 튜플을 제거
### 제 2 정규화
제 1 정규화를 거친 테이블에서 **완전 함수 종속을 만족**하도록 테이블을 분해하는것.
> [!NOTE] 완전 함수 종속
> 테이블 **기본키의 부분집합**에 의해 **컬럼이 결정되지 않도록** 하는것을 말한다.
> 
> 예를들어 기본키 (학생번호, 강좌이름)이 존재한다 그런데 기본키의 부분집합인 (강좌이름)을 통해 강의실 컬럼을 결정할 수 있다면 완전 함수 종속을 만족하지 못한다 볼 수 있다.
> 
> 이럴때 강좌이름을 통해 결정되는 컬럼들을 따로 테이블로 분리하면 완전 함수 종속을 만족 시킬 수 있다.

###### 제 2 정규화 이전
![[Pasted image 20250307111532.png]]
###### 제 2 정규화 이후
![[Pasted image 20250307105307.png]]
기존 테이블은 기본키가 (학생번호, 강좌이름)인 복합키다, 그리고 복합키의 부분집합인 강좌이름이 강의실 데이터를 결정짓고 있다.

이런경우 테이블에서 강의실 정보를 보고싶을때 학생번호, 성적까지 불필요한 데이터가 조회되는 문제가 있다. 이 문제는 강좌에 관한 테이블을 따로 분리해 완전 함수 종속을 만족시켜 해결 가능하고 이러한 과정을 제 2 정규화라고 부른다.
##### 효과
* 중복을 줄일 수 있다
* 정확한 데이터 구조를 형성 시킬 수 있다
* 삽입, 삭제, 수정 이상현상을 막을 수 있다
* 위 3가지로 데이터 무결성을 유지시킬 수 있다
### 제 3 정규화
제 2 정규화를 거친 테이블에서 **이행적 종속을 제거**하도록 테이블을 분리하는것
> [!NOTE] 이행적 종속
> 이행적 종속은 A->B, B->C가 성립할때 A->C가 성립 되는것을 말한다.
> 
>이행정 종속이 있을때 문제점은 B를 변경할때 C도 함께 변경하지 않으면 데이터 부정합이 발생한다는 것이다.
>
>예를들어 A는 학생번호 B는 강좌이름 C는 수강료다
>학생번호는 강좌이름을, 강좌이름은 수강료를 결정하므로 학생번호는 수강료를 결정하는 이행적 종속이다. 마찬가지로 문제점은 강좌이름을 변경할때 수강료를 함께 변경하지 않는다면 이전강좌 수강료가 사용되는 부정합이 발생한다.

###### 제 3 정규화 이전
![[Pasted image 20250307130731.png]]
###### 제 3 정규화 이후
![[Pasted image 20250307130824.png]]
기존 테이블은 학생번호->강좌이름, 강좌이름->수강료, 학생번호->수강료를 만족하는 이행정 종속 테이블이다. 가지고 있는 문제점은 강좌이름을 변경할때 수강료도 함께 변경하지 않는다면 이전 강좌 수강료를 사용하는 데이터 부정합이 발생한다는것이다.

이런경우 강좌이름을 분기점으로 테이블을 나눠 이행적 종속을 제거해 문제를 해결할 수 있다. 이러한 과정을 제 3 정규화라고 부른다.
##### 효과
<span style="font-size: 12px">제 2 정규화와 효과가 같다</span>
* 중복을 줄일 수 있다
* 정확한 데이터 구조를 형성 시킬 수 있다
* 삽입, 삭제, 수정 이상현상을 막을 수 있다
* 위 3가지로 데이터 무결성을 유지시킬 수 있다
### BCNF 정규화
제 3 정규화를 거친 테이블에서 모든 결정자가 후보키가 되도록 테이블을 분해하는것
###### BCNF 정규화 이전
![[Pasted image 20250311214246.png]]
###### BCNF 정규화 이후
![[Pasted image 20250311214323.png]]
기존 테이블은 기본키가 (학생번호, 특강이름)인 복합키다, 학생번호와 특강이름은 교수를 결정하고있으며, 교수는 특강이름을 결정하고 있다.

이런경우 교수를 변경했을때 특강이름은 변경되지 않아 수정 이상이 발생할 수 있다. 이 문제는 교수가 후보키가 되도록 테이블을 분해하면 해결 가능하고 이러한 과정을 BCNF 정규화라고 부른다.
##### 효과
<span style="font-size: 12px">제 3 정규화와 효과가 같다</span>
* 중복을 줄일 수 있다
* 정확한 데이터 구조를 형성 시킬 수 있다
* 삽입, 삭제, 수정 이상현상을 막을 수 있다
* 위 3가지로 데이터 무결성을 유지시킬 수 있다
###### 참고 및 출처
https://mangkyu.tistory.com/110